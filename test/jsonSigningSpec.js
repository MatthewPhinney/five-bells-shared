'use strict'

// Test jsonSigning utility

const chai = require('chai')
const expect = chai.expect
const jsonSigning = require('../utils/jsonSigning')
const rsasign = require('jsrsasign')
const signData = require('./data/signData')
const fs = require('fs')

const Validator = require('../lib/validator')
const validator = new Validator()
validator.loadSharedSchemas()

function validateNotification (json) {
  const validatorResult = validator.create('Notification')(json)
  if (!validatorResult.valid) {
    throw new Error('Notification schema validation error: ' + validatorResult.errors[0])
  }
}

// Set up keys
const prvPEM = fs.readFileSync('test/data/signKeyPrv.pem', 'utf8')
const pubPEM = fs.readFileSync('test/data/signKeyPub.pem', 'utf8')
const prvKey = rsasign.KEYUTIL.getKey(prvPEM, 'pass', 'AES-256-CBC')
const pubKey = rsasign.KEYUTIL.getKey(pubPEM, 'PKCS8PUB')

// Keys were generated by:
// openssl genrsa -out signKeyRSAPrv.pem 4096
// openssl rsa -in signKeyRSAPrv.pem -outform PEM -pubout -out signKeyRSAPub.pem
const prvRSAPEM = fs.readFileSync('test/data/signKeyRSAPrv.pem', 'utf8')
const pubRSAPEM = fs.readFileSync('test/data/signKeyRSAPub.pem', 'utf8')

const pubRSAPEM2 = fs.readFileSync('test/data/signKeyRSAPub2.pem', 'utf8')

describe('jsonSigningTests', function () {
  describe('jsonSigning', function () {
    it('should sign JSON object successfully', function () {
      const signedJSON = jsonSigning.sign(signData.sampleNotification, jsonSigning.types.ES256, prvKey, pubKey)
      expect(validateNotification.bind(validator.validateNotification, signedJSON)).to.not.throw(Error)
      // Do not check signature.value, because this value changes every time it signs
      delete signedJSON.signature.value
      expect(signedJSON).to.deep.equal(signData.expectedSignedNotification)
    })
  })

  describe('jsonSignAndVerify', function () {
    it('should sign and verify JSON object successfully', function () {
      const signedJSON = jsonSigning.sign(signData.sampleNotification, jsonSigning.types.ES256, prvKey, pubKey)
      const result = jsonSigning.verify(signedJSON, pubKey)
      expect(result.valid).to.be.true
    })
  })

  describe('jsonInvalidSignature', function () {
    it('should catch invalid JSON signature', function () {
      const signedJSON = jsonSigning.sign(signData.sampleNotification, jsonSigning.types.ES256, prvKey, pubKey)
      // Modify signature value to make verification fail
      signedJSON.signature.value += 'X'
      const result = jsonSigning.verify(signedJSON, pubKey)
      expect(result.valid).to.be.false
    })
  })

  describe('jsonInvalidPublicKey', function () {
    it('should return valid: false', function () {
      const signedJSON = jsonSigning.sign(signData.sampleNotification, jsonSigning.types.ES256, prvKey, pubKey)
      signedJSON.signature.publicKey.y += 'X'
      expect(jsonSigning.verify(signedJSON, pubKey)).to.deep.equal({
        valid: false,
        error: 'Public key mismatch in JSON signature verification'
      })
    })
  })

  describe('jsonRSASigning', function () {
    it('should sign JSON object with RSA successfully', function () {
      const signedJSON = jsonSigning.sign(signData.sampleNotification, jsonSigning.types.PS256, prvRSAPEM)
      expect(validateNotification.bind(validator.validateNotification, signedJSON)).to.not.throw(Error)
      // Do not check signature.value, because this value changes every time it signs
      delete signedJSON.signature.value
      expect(signedJSON).to.deep.equal(signData.expectedRSASignedNotification)
    })
  })

  describe('jsonRSASignAndVerify', function () {
    it('should sign and verify JSON object with RSA successfully', function () {
      const signedJSON = jsonSigning.sign(signData.sampleNotification, jsonSigning.types.PS256, prvRSAPEM)
      const result = jsonSigning.verify(signedJSON, pubRSAPEM)
      expect(result.valid).to.be.true
    })
  })

  describe('jsonRSAInvalidSignature', function () {
    it('should catch invalid JSON signature with RSA', function () {
      const signedJSON = jsonSigning.sign(signData.sampleNotification, jsonSigning.types.PS256, prvRSAPEM)
      signedJSON.signature.value += 'X'
      const result = jsonSigning.verify(signedJSON, pubRSAPEM)
      expect(result.valid).to.be.false
    })
  })

  describe('jsonRSAInvalidPublicKey', function () {
    it('should return valid: false', function () {
      const signedJSON = jsonSigning.sign(signData.sampleNotification, jsonSigning.types.PS256, prvRSAPEM)
      signedJSON.signature.publicKey.n += 'X'
      expect(jsonSigning.verify(signedJSON, pubRSAPEM)).to.deep.equal({
        valid: false,
        error: 'Public key mismatch in JSON signature verification'
      })
    })
  })

  describe('verify()', () => {
    it('returns valid: false on invalid input', () => {
      const result = jsonSigning.verify({foo: 'bar'}, pubKey)
      expect(result).to.deep.equal({
        valid: false,
        error: 'Invalid input'
      })
    })

    it('invalid algorithm', () => {
      const signedJSON = jsonSigning.sign(signData.sampleNotification, jsonSigning.types.PS256, prvRSAPEM)
      signedJSON.signature.algorithm = 'foo'
      const result = jsonSigning.verify(signedJSON, pubKey)
      expect(result).to.deep.equal({
        valid: false,
        error: 'Unsupported crypto algorithm'
      })
    })

    it('public key mismatch', () => {
      const signedJSON = jsonSigning.sign(signData.sampleNotification, jsonSigning.types.PS256, prvRSAPEM)
      const result = jsonSigning.verify(signedJSON, pubRSAPEM2)
      expect(result).to.deep.equal({
        valid: false,
        error: 'Public key mismatch in JSON signature verification'
      })
    })
  })
})
